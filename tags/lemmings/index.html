<html>
<head>
  <meta charset="UTF-8">
  <title>
    Tag: lemmings — Sorawee's Website
  </title>
  <link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" media="all" href="../../css/styles.css" />
  <link rel="stylesheet" type="text/css" media="all" href="../../css/normalize.css" />
  <link rel="stylesheet" type="text/css" media="all" href="../../css/styles-github.css" />
  <script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});
  </script>
  <style type="text/css">.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */</style>
</head>
<body>

  <section class="page-header">
    <h1 class="project-name">
      <a href="../../">Sorawee's Website</a>
    </h1>
    <h2 class="project-tagline"></h2>
    <a href="../../" class="btn">Blog</a>
    <a href="../../books.html" class="btn">Books</a>
    <a href="../../feed.xml" class="btn">RSS</a>
    <a href="../../about.html" class="btn">About Me</a>
  </section>
  <section class="main-content" id="the-main">
    <div id="real-content">
      <h1>Tag: lemmings</h1><h2><a href="/blog/2016-12-27-lemmo.html"><span class="smallcaps">Lemmo</span></a></h2><p class="tags">Tags: <a href="/tags/competition">competition</a>, <a href="/tags/programming">programming</a>, <a href="/tags/lemmings">lemmings</a></p><p class="pubdate">Published on Tuesday, December 27th, 2016</p><div class="content"><p>Wandering around in Wikipedia yesterday, I found this article: <i><a href="https://en.wikipedia.org/wiki/Lemmings_(video_game)">Lemmings</a></i>. Though I never play this game before,  I have played its open-source clone, <i><a href="https://pingus.seul.org">Pingus</a></i>, which is really enjoyable<label for="2ccab9c2-dd06-4427-b63a-e9cbd5d4734c" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2ccab9c2-dd06-4427-b63a-e9cbd5d4734c" class="margin-toggle"/><span class="sidenote">I in fact have devised a pretty good (if not optimal) <a href="https://www.youtube.com/watch?v=Wdl9bBUmU-k">strategy</a> for a level several years ago.</span>. This post is written to pay tribute to this wonderful game.</p><p><see-more></see-more></p><p><center><img src="https://upload.wikimedia.org/wikipedia/en/0/0c/Lemmings-BoxScan.jpg"/></center></p><p>Anyway, the post is not really going to be about the game. <i>Lemmings</i> also reminds me of something else too. Several years ago, I attempted to solve a programming puzzle and failed. Then I tried again a year after that, and for this time, I succeeded. It became one of my favorite puzzles because of its trickiness under a seemingly simple problem. This programming puzzle is known as <i>Lemmo</i><label for="e8331b1c-8ad7-404b-8e8f-1ee66a29aed3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="e8331b1c-8ad7-404b-8e8f-1ee66a29aed3" class="margin-toggle"/><span class="sidenote">Here is the <a href="http://theory.cpe.ku.ac.th/~pramook/ioi/2011/oct12_lemmo.pdf">original problem statement</a> (in Thai)</span>. Indeed, it’s a yet another variant of <i>Lemmings</i>.</p><p>Lemmo is a simple creature. All it does is merely walking. When hitting a wall, it turns around. When stepping over a space, it falls<label for="bed04276-bc1e-4ee9-8437-c9d27878962d" class="margin-toggle sidenote-number"></label><input type="checkbox" id="bed04276-bc1e-4ee9-8437-c9d27878962d" class="margin-toggle"/><span class="sidenote">Lemmo will survive however high it falls. This is not true in the original <i>Lemmings</i>.</span>. It is guaranteed that the map that Lemmo is going to be in will have at least a space for every non-first floor. That is, Lemmo will definitely reach the first floor. The game ends when Lemmo steps over either a treasure box or a bottomless sewer drain, located on only the first floor. As you can anticipate, finding a treasure box is a win, while falling into a bottomless sewer drain is a lose. It is also guaranteed that there will be at least one treasure box or one sewer drain, and that there is no space on the first floor. That is, the game will always end.</p><p>Let <mathjax>$r, c$</mathjax> be the number of rows and columns of the map respectively. Initially, Lemmo will start on the highest floor, which could be in <mathjax>$c$</mathjax> different positions. It can either face to the left or to the right. Therefore, there are <mathjax>$2c$</mathjax> initial configurations.</p><p><button id="start">Start</button> <button id="stop">Stop</button> <button id="reset">Reset</button></p><table><tr><td><canvas id="game" width="560" height="200"></canvas></td></tr></table><p><script>const map = [
  "#####.###.##",
  "###.#####.##",
  "#.####.#####",
  "@#@$@$######"
];
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const rows = map.length;
const cols = map[0].length;
const height_gap = 40;
const width_gap = 45;
const center_width = width_gap / 2;
const center_height = 2 * height_gap / 5;
const margin_left = 10;
const margin_top = 10;
const color_white = "#FFFFFF";
const color_yellow = "#CCCC00";
const color_red = "#FF0000";
const color_black = "#000000";
const color_blue = "#0095DD";
let pos_x = 0;
let pos_y = 0;
let dir = 1;
const radius_ball = 10;

function get_x(x) {
  return x * width_gap + margin_left;
}

function get_y(x) {
  return x * height_gap + margin_top;
}

let intv = null;
let setup_step = true;

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (var i = 0; i < rows; ++i) {
    for (var j = 0; j < cols; ++j) {
      if (map[i][j] != ".") {
        ctx.beginPath();
        ctx.rect(get_x(j), get_y(i) + ((height_gap * 4) / 5), width_gap - 1, height_gap / 5);
        ctx.fillStyle = color_red;
        ctx.fill();
        ctx.closePath();
        let color = color_white;
        if (map[i][j] == "#") {
          color = color_white;
        } else if (map[i][j] == "$") {
          color = color_yellow;
        } else if (map[i][j] == "@") {
          color = color_black;
        } else {
          throw new Error("Incorrect map value");
        }
        ctx.beginPath();
        ctx.arc(get_x(j) + center_width, get_y(i) + center_height, 9, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
      }
    }
  }
  ctx.beginPath();
  if (dir == 1) {
    ctx.moveTo(get_x(pos_x) + center_width - (height_gap / 5), get_y(pos_y) + center_height - (height_gap / 5));
    ctx.lineTo(get_x(pos_x) + center_width - (height_gap / 5), get_y(pos_y) + center_height + (height_gap / 5));
    ctx.lineTo(get_x(pos_x) + center_width + (height_gap / 5), get_y(pos_y) + center_height);
  } else if (dir == -1) {
    ctx.moveTo(get_x(pos_x) + center_width + (height_gap / 5), get_y(pos_y) + center_height - (height_gap / 5));
    ctx.lineTo(get_x(pos_x) + center_width + (height_gap / 5), get_y(pos_y) + center_height + (height_gap / 5));
    ctx.lineTo(get_x(pos_x) + center_width - (height_gap / 5), get_y(pos_y) + center_height);
  } else {
    throw new Error("dir is not 1 or -1");
  }
  ctx.fillStyle = color_blue;
  ctx.fill();
  ctx.closePath();
}

draw();

function act() {
  draw();
  if (map[pos_y][pos_x] == ".") {
    pos_y += 1;
  } else if (map[pos_y][pos_x] == "#") {
    pos_x += dir;
    if (pos_x < 0) {
      pos_x = 0;
      dir *= -1;
    }
    if (pos_x > cols - 1) {
      pos_x = cols - 1;
      dir *= -1;
    }
  } else {
    clearInterval(intv);
  }
}

function start_fun() {
  setup_step = false;
  if (intv == null) {
    intv = setInterval(act, 300);
  }
}

function stop_fun() {
  if (intv != null) {
    clearInterval(intv);
    intv = null;
  }
}

function reset_fun() {
  stop_fun();
  setup_step = true;
  pos_x = 0;
  pos_y = 0;
  dir = 1;
  draw();
}

document.getElementById("start").onclick = start_fun;
document.getElementById("stop").onclick = stop_fun;
document.getElementById("reset").onclick = reset_fun;

document.addEventListener("keydown", function(e) {
  if (!setup_step) return;
  if(e.keyCode == 90) dir = -1; // z
  if(e.keyCode == 88) dir = 1; // x
  if(e.keyCode == 37) pos_x = Math.max(pos_x - 1, 0); // left
  if(e.keyCode == 39) pos_x = Math.min(pos_x + 1, cols - 1); // right
  draw();
}, false);</script></p><p><i>Use the following keys to setup the initial configuration: <kbd>Left</kbd> to move left, <kbd>Right</kbd> to move right, <kbd>z</kbd> to face to the left, <kbd>x</kbd> to face to the right. Then click <code>Start</code> to begin the game.</i></p><p><u>Task 1: Write a program to find how many different initial configurations will lead Lemmo to a treasure box?</u></p><p><u>Task 2: Write a program to find the maximum number of different initial configurations that will lead Lemmo to a treasure box, provided that you are allowed to remove no more than one block from a non-first floor (that is, turning no more than one block into a space)?</u></p><p>Here’s the constraints:</p><ul><li>Time limit: 1 second</li><li>Memory limit: 32MB</li><li><mathjax>$1 \le r, c \le 1000$</mathjax></li></ul><p>The input will be in the following format:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="source"><pre><span></span>#####.###.##
###.#####.##
#.####.#####
@#@$@$######
</pre></div></td></tr></tbody></table></div><p>where <code>@</code> indicates a bottomless sewer drain, <code>#</code> indicates a block on a floor, <code>.</code> indicates a space, and <code>$</code> indicates a treasure box.</p><p>In the above example, the configurations facing left in the column 6, 7, 8, 9 will lead to the leftmost bottomless sewer drain, while the rest will lead to the rightmost treasure box. However, if we remove the block at row 3, column 4, all configurations will lead to a treasure box. Therefore, the answer should be 20 and 24 respectively.</p><p>Following is my solution and explanation. Do not read if you wish not to see a spoiler. I have warned you.</p><p>.<br/>.<br/>.</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="kn">#lang </span><span class="nn">racket</span>

<span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">SPACE</span> <span class="n">BLOCK</span> <span class="n">WIN</span> <span class="n">LOSE</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply</span> <span class="nb">values</span> <span class="p">(</span><span class="nb">string-&gt;list</span> <span class="s2">".#$@"</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">memoize</span> <span class="n">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">mem</span> <span class="p">(</span><span class="nb">make-hash</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="n">args</span> <span class="p">(</span><span class="nb">hash-ref!</span> <span class="n">mem</span> <span class="n">args</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">apply</span> <span class="n">f</span> <span class="n">args</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">calc</span> <span class="n">lines</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">table</span>
    <span class="p">(</span><span class="nb">list-&gt;vector</span>
     <span class="p">(</span><span class="nb">append</span>
      <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">build-vector</span> <span class="p">(</span><span class="nb">string-length</span> <span class="p">(</span><span class="nb">first</span> <span class="n">lines</span><span class="p">))</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="k">_</span><span class="p">)</span> <span class="n">SPACE</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="p">(</span><span class="nb">list-&gt;vector</span> <span class="p">(</span><span class="nb">string-&gt;list</span> <span class="n">line</span><span class="p">)))</span> <span class="n">lines</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">normalize</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">x</span> <span class="n">SPACE</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">table-sum</span>
    <span class="p">(</span><span class="nb">vector-map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">row-vector</span><span class="p">)</span>
                  <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="k">_</span> <span class="n">lst</span><span class="p">)</span>
                    <span class="p">(</span><span class="k">for/fold</span> <span class="p">([</span><span class="n">sum</span> <span class="mi">0</span><span class="p">]</span> <span class="p">[</span><span class="n">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span> <span class="p">([</span><span class="n">e</span> <span class="n">row-vector</span><span class="p">])</span>
                      <span class="p">(</span><span class="k">define</span> <span class="n">next-sum</span> <span class="p">(</span><span class="nb">+</span> <span class="n">sum</span> <span class="p">(</span><span class="n">normalize</span> <span class="n">e</span><span class="p">)))</span>
                      <span class="p">(</span><span class="nb">values</span> <span class="n">next-sum</span> <span class="p">(</span><span class="nb">cons</span> <span class="n">next-sum</span> <span class="n">lst</span><span class="p">))))</span>
                  <span class="p">(</span><span class="nb">list-&gt;vector</span> <span class="p">(</span><span class="nb">reverse</span> <span class="n">lst</span><span class="p">)))</span>
                <span class="n">table</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">i</span> <span class="n">j</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="n">table</span> <span class="n">i</span><span class="p">)</span> <span class="n">j</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">rows</span> <span class="p">(</span><span class="nb">vector-length</span> <span class="n">table</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">cols</span> <span class="p">(</span><span class="nb">vector-length</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="n">table</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">next</span> <span class="n">prev</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nb">+</span> <span class="nb">-</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">lookup-sum</span> <span class="n">i</span> <span class="n">j</span><span class="p">)</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="n">table-sum</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">add1</span> <span class="n">j</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">has-all?</span> <span class="n">r</span> <span class="n">i</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">+</span> <span class="n">j</span> <span class="p">(</span><span class="nb">-</span> <span class="n">i</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="n">lookup-sum</span> <span class="n">r</span> <span class="n">j</span><span class="p">)</span> <span class="p">(</span><span class="n">lookup-sum</span> <span class="n">r</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">i</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">get-hmove</span> <span class="n">c</span> <span class="n">dir</span> <span class="n">change</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="n">maybe-c</span> <span class="p">(</span><span class="n">change</span> <span class="n">c</span> <span class="n">dir</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="n">maybe-c</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="n">maybe-c</span> <span class="n">cols</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">values</span> <span class="n">c</span> <span class="p">(</span><span class="nb">-</span> <span class="n">dir</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">values</span> <span class="n">maybe-c</span> <span class="n">dir</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">define</span> <span class="n">calc1</span>
    <span class="p">(</span><span class="n">memoize</span>
     <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">r</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)</span>
       <span class="p">(</span><span class="k">cond</span>
         <span class="p">[(</span><span class="nb">zero?</span> <span class="n">r</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
         <span class="p">[</span><span class="k">else</span>
          <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">p-c</span> <span class="n">p-dir</span><span class="p">)</span> <span class="p">(</span><span class="n">get-hmove</span> <span class="n">c</span> <span class="n">dir</span> <span class="n">prev</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">SPACE</span> <span class="p">(</span><span class="n">lookup</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">r</span><span class="p">)</span> <span class="n">c</span><span class="p">))</span>
                 <span class="p">(</span><span class="n">calc1</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">r</span><span class="p">)</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)</span>
                 <span class="mi">0</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">member</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">r</span> <span class="n">p-c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="n">SPACE</span> <span class="n">WIN</span> <span class="n">LOSE</span><span class="p">))</span>
                 <span class="mi">0</span>
                 <span class="p">(</span><span class="n">calc1</span> <span class="n">r</span> <span class="n">p-c</span> <span class="n">p-dir</span><span class="p">)))]))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="n">win?</span>
    <span class="p">(</span><span class="n">memoize</span>
     <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">r</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)</span>
       <span class="p">(</span><span class="k">match</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">r</span> <span class="n">c</span><span class="p">)</span>
         <span class="p">[(</span><span class="k">==</span> <span class="n">WIN</span><span class="p">)</span> <span class="no">#t</span><span class="p">]</span>
         <span class="p">[(</span><span class="k">==</span> <span class="n">LOSE</span><span class="p">)</span> <span class="no">#f</span><span class="p">]</span>
         <span class="p">[(</span><span class="k">==</span> <span class="n">SPACE</span><span class="p">)</span> <span class="p">(</span><span class="n">win?</span> <span class="p">(</span><span class="nb">add1</span> <span class="n">r</span><span class="p">)</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)]</span>
         <span class="p">[(</span><span class="k">==</span> <span class="n">BLOCK</span><span class="p">)</span>
          <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">p-c</span> <span class="n">p-dir</span><span class="p">)</span> <span class="p">(</span><span class="n">get-hmove</span> <span class="n">c</span> <span class="n">dir</span> <span class="n">next</span><span class="p">))</span>
          <span class="p">(</span><span class="n">win?</span> <span class="n">r</span> <span class="n">p-c</span> <span class="n">p-dir</span><span class="p">)]))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">delta-from-remove</span> <span class="n">r</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">[(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">BLOCK</span> <span class="p">(</span><span class="n">lookup</span> <span class="n">r</span> <span class="n">c</span><span class="p">)))</span> <span class="mi">0</span><span class="p">]</span>
      <span class="p">[</span><span class="k">else</span>
       <span class="p">(</span><span class="k">define</span> <span class="n">proc</span>
         <span class="p">(</span><span class="k">cond</span>
           <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="n">win?</span> <span class="p">(</span><span class="nb">add1</span> <span class="n">r</span><span class="p">)</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">win?</span> <span class="n">r</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)))</span> <span class="nb">+</span><span class="p">]</span>
           <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">win?</span> <span class="p">(</span><span class="nb">add1</span> <span class="n">r</span><span class="p">)</span> <span class="n">c</span> <span class="n">dir</span><span class="p">))</span> <span class="p">(</span><span class="n">win?</span> <span class="n">r</span> <span class="n">c</span> <span class="n">dir</span><span class="p">))</span> <span class="nb">-</span><span class="p">]</span>
           <span class="p">[</span><span class="k">else</span> <span class="no">#f</span><span class="p">]))</span>
       <span class="p">(</span><span class="k">cond</span>
         <span class="p">[</span><span class="n">proc</span>
          <span class="p">(</span><span class="k">define</span> <span class="n">over-calc</span>
            <span class="p">(</span><span class="k">cond</span>
              <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">=</span> <span class="n">dir</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="n">has-all?</span> <span class="n">r</span> <span class="n">c</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">cols</span><span class="p">)))</span> <span class="p">(</span><span class="n">calc1</span> <span class="n">r</span> <span class="n">c</span> <span class="mi">1</span><span class="p">)]</span>
              <span class="p">[(</span><span class="k">and</span> <span class="p">(</span><span class="nb">=</span> <span class="n">dir</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">has-all?</span> <span class="n">r</span> <span class="mi">0</span> <span class="n">c</span><span class="p">))</span> <span class="p">(</span><span class="n">calc1</span> <span class="n">r</span> <span class="n">c</span> <span class="mi">-1</span><span class="p">)]</span>
              <span class="p">[</span><span class="k">else</span> <span class="mi">0</span><span class="p">]))</span>
          <span class="p">(</span><span class="n">proc</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="n">calc1</span> <span class="n">r</span> <span class="n">c</span> <span class="n">dir</span><span class="p">)</span> <span class="n">over-calc</span><span class="p">))]</span>
         <span class="p">[</span><span class="k">else</span> <span class="mi">0</span><span class="p">])]))</span>

  <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">first-sol</span><span class="p">)</span>
    <span class="p">(</span><span class="k">for/fold</span> <span class="p">([</span><span class="n">sum</span> <span class="mi">0</span><span class="p">])</span> <span class="p">([</span><span class="n">c</span> <span class="p">(</span><span class="nb">in-range</span> <span class="n">cols</span><span class="p">)])</span>
      <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">+</span> <span class="n">sum</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">WIN</span> <span class="p">(</span><span class="n">lookup</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">rows</span><span class="p">)</span> <span class="n">c</span><span class="p">))</span>
                         <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">calc1</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">rows</span><span class="p">)</span> <span class="n">c</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">calc1</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">rows</span><span class="p">)</span> <span class="n">c</span> <span class="mi">-1</span><span class="p">))</span>
                         <span class="mi">0</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">second-sol</span><span class="p">)</span>
    <span class="p">(</span><span class="k">for/fold</span> <span class="p">([</span><span class="n">sol</span> <span class="mi">0</span><span class="p">])</span> <span class="p">([</span><span class="n">r</span> <span class="p">(</span><span class="nb">in-range</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">rows</span><span class="p">))])</span> <span class="c1">; only non-first floor</span>
      <span class="p">(</span><span class="k">define-values</span> <span class="p">(</span><span class="n">sub-sol</span><span class="p">)</span>
        <span class="p">(</span><span class="k">for/fold</span> <span class="p">([</span><span class="n">sub-sol</span> <span class="n">sol</span><span class="p">])</span> <span class="p">([</span><span class="n">c</span> <span class="p">(</span><span class="nb">in-range</span> <span class="n">cols</span><span class="p">)])</span>
          <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">max</span> <span class="n">sub-sol</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">delta-from-remove</span> <span class="n">r</span> <span class="n">c</span> <span class="mi">-1</span><span class="p">)</span>
                                  <span class="p">(</span><span class="n">delta-from-remove</span> <span class="n">r</span> <span class="n">c</span> <span class="mi">1</span><span class="p">))))))</span>
      <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">max</span> <span class="n">sol</span> <span class="n">sub-sol</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">values</span> <span class="n">first-sol</span> <span class="p">(</span><span class="nb">+</span> <span class="n">first-sol</span> <span class="n">second-sol</span><span class="p">)))</span>

<span class="p">(</span><span class="n">calc</span> <span class="o">&#39;</span><span class="p">(</span><span class="s2">"#####.###.##"</span>
        <span class="s2">"###.#####.##"</span>
        <span class="s2">"#.####.#####"</span>
        <span class="s2">"@#@$@$######"</span><span class="p">))</span>
</pre></div></td></tr></tbody></table></div><p>Just below 100 lines, in Racket!</p><p>This results in:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="source"><pre><span></span>20
24
</pre></div></td></tr></tbody></table></div><p>which is the correct answer.</p><h2>Explanation</h2><h3>First Task</h3><p>The naive way to solve the first task is to simulate all possible configurations (in the order of <mathjax>$O(c)$</mathjax>). Simulation is feasible because any initial configurations will lead to either a treasure box or a bottomless sewer drain eventually, so the simulation will terminate. However, a map like this:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="source"><pre><span></span>#########.
.#########
#########$
</pre></div></td></tr></tbody></table></div><p>would make Lemmo walk over every block (in the order of <mathjax>$O(rc)$</mathjax>). Thus, it would run in <mathjax>$O(rc^2)$</mathjax>. This would be too slow to finish in one second.</p><p>This is when dynamic programming comes to rescue. What we want to know is the number of ways that Lemmo will reach any treasure box from all possible configurations. Instead of computing that directly, we will generalize it by computing the number of ways that Lemmo will reach a certain position (facing in a certain direction) from all possible configurations. Then, we notice that this computation relates to the number of ways to reach the previous step. For example, in this map:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="source"><pre><span></span>+------------
|
|  #.##.####.
|      ←
|  .#########
|
|  #########$
</pre></div></td></tr></tbody></table></div><p>To be at <code>←</code> (facing to the left, as suggested by the arrow), Lemmo must come from either the above (the above is a space, so it’s possible that Lemmo will get here by falling from there), or from the right.</p><p>To illustrate, the number of initial configurations that could make Lemmo to be at <code>←</code> is 15.</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="source"><pre><span></span>    →→→→→→→→→
       ←←←←←←
+------------
|
|  #.##.####.
|      ←
|  .#########
|
|  #########$
</pre></div></td></tr></tbody></table></div><p>which is merely the number of ways that Lemmo can reach the above (5)</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="source"><pre><span></span>       ←←←←←
+------------
|      ←
|  #.##.####.
|
|  .#########
|
|  #########$
</pre></div></td></tr></tbody></table></div><p>plus the number of ways that Lemmo can reach the right (10)</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="source"><pre><span></span>    →→→→→→→→→
            ←
+------------
|
|  #.##.####.
|       ←
|  .#########
|
|  #########$
</pre></div></td></tr></tbody></table></div><p>Let’s now formalize it. Let <mathjax>$W_{i, j, d}$</mathjax> be the number of ways to reach position at row <mathjax>$i \in \{1,2,...,r\}$</mathjax>, column <mathjax>$j \in \{1,2,...,c\}$</mathjax>, and <mathjax>$d \in \{ L, R \}$</mathjax> indicates the direction that Lemmo is facing. This corresponds to the function <code>calc1</code> in line 37.</p><ul><li><p>Base case: to simplify things, let’s add another layer, row 0, to the map where I will refer to as “sky.” Sky, as the name suggested, is all spaces (no block). We will then drop Lemmo from the sky instead. This will not affect the answer, since eventually Lemmo will fall to the original place anyway. However, we now have a clear base case, as there is exactly one way to reach it (which is by dropping it there). Therefore, <mathjax>$W_{0, j, L} = W_{0, j, R} = 1$</mathjax> for all <mathjax>$j$</mathjax>.</p><p>Adding the sky layer (row 0) corresponds to line 13. The base case corresponds to line 41.</p></li><li><p>Inductive case: if it’s not the base case, then Lemmo can be at position <mathjax>$i, j$</mathjax> facing in the direction <mathjax>$d$</mathjax> by two ways:</p><ol><li>From the space above: therefore, this is only applicable when the above is a space. Note that if Lemmo comes from the above, during the fall, it couldn’t change a direction. Thus, if it is applicable, we know already what is the number of ways to get to the above: <mathjax>$W_{i - 1, j, d}$</mathjax>. This corresponds to line 44.</li><li><p>From behind (in the same row): this part is a little bit tricky. Suppose the behind position is a space, then Lemmo would fall to the lower floor. It can’t jump to this position. Similarly, if the behind position is a treasure box or a bottomless sewer drain, then the game would have ended already. These are the cases that are not applicable.</p><p>But moreover, there is one special case: suppose we are adjacent to a wall (either left or right wall) and facing out of the wall, then the behind position can’t be within the wall. It would instead come from the exactly same position, but facing in the other direction. In the normal case however, the direction would still need to be maintained, as Lemmo will not switch the direction unless it’s the special case.</p><p>Thus, if it’s applicable, the number of ways to get to the behind position is <mathjax>$W_{i, j’, d’}$</mathjax> where <mathjax>$j’$</mathjax> is the behind position, and <mathjax>$d’$</mathjax> is the direction in the behind position (<mathjax>$d’ \ne d$</mathjax> if it’s a special case, but would be the same otherwise). This corresponds to line 47. Note that the function <code>get-hmove</code> in line 31 is for computing the behind position (and its direction).</p></li></ol><p>Therefore:</p><p><mathjax>$W_{i, j, d} = \begin{cases}
  W_{i - 1, j, d} + W_{i, j’, d’} &amp; \text{if both the above case}\\ &amp; \text{and the behind case work}\\
  W_{i - 1, j, d} &amp; \text{if only the above case works}\\
  W_{i, j’, d’} &amp; \text{if only the behind case works}\\
  0 &amp; \text{otherwise}\\
\end{cases}$</mathjax></p><p>which corresponds to line 44.</p></li></ul><p>Regarding the time complexity, for each <mathjax>$i, j, d$</mathjax>, we compute <mathjax>$W_{i, j, d}$</mathjax> in constant time, provided that other values in <mathjax>$W$</mathjax> is calculated already. With <a href="http://papl.cs.brown.edu/2016/Algorithms_That_Exploit_State.html#(part._.Abstracting_.Memoization)">memoization</a>, it takes <mathjax>$O(rc)$</mathjax> to compute any (and all) <mathjax>$W_{i, j, d}$</mathjax>.</p><p>To finish the first task, we need to calculate an answer, and this is straightforward: it’s just the sum of number of ways to get to all treasure boxes, from both <mathjax>$L$</mathjax> and <mathjax>$R$</mathjax> directions. This corresponds to line 79.</p><h3>Second Task</h3><p>The naive way would be to try removing each block at a time in the map, and run the first task’s algorithm to evaluate how many initial configurations that will lead to a treasure box increases after the removal. However, the number of blocks is in order of <mathjax>$O(rc)$</mathjax>, and the algorithm in the first task takes <mathjax>$O(rc)$</mathjax>. This would result in an <mathjax>$O((rc)^2)$</mathjax>-algorithm. Bad!</p><p>One important fact is that Lemmo’s walk is deterministic. Therefore, a position and the direction completely determines Lemmo’s eventual destination. That is, it is possible compute <mathjax>$A_{i, j, d} \in \{T_1, T_2, ..., T_t, F_1, F_2, ..., F_f\}$</mathjax> where <mathjax>$T_1, T_2, ..., T_t$</mathjax> are all treasure boxes, and <mathjax>$F_1, F_2, ..., F_f$</mathjax> are bottomless sewer drains, and <mathjax>$i \in \{1,2,...,r\}, j \in \{1,2,...,c\}, d \in \{ L, R \}$</mathjax>. This, again, uses dynamic programming which is perhaps even easier than that in the first task, so I will skip the explanation.</p><p>Note, though, that this is even too detailed. We don’t really want to know where exactly Lemmo will end up. We only want to know whether it will find a treasure box or it will fall into a bottomless sewer drain, as that’s what we need to know to calculate the answer. Thus, we will refine the previous definition: we will compute <mathjax>$A_{i, j, d} \in \{T, F\}$</mathjax> where <mathjax>$T$</mathjax> indicates that the eventual destination is a treasure box, and <mathjax>$F$</mathjax> indicates that the eventual destination is a bottomless sewer drains. This corresponds to line 50. Note that it could be the case that the state <mathjax>$(i, j, d)$</mathjax> might not be reachable at all, but suppose we somehow place Lemmo there, <mathjax>$A_{i,j,d}$</mathjax> would determine the future status of Lemmo correctly.<label for="29d3f47f-a991-4575-b8d8-b88600c88a5d" class="margin-toggle sidenote-number"></label><input type="checkbox" id="29d3f47f-a991-4575-b8d8-b88600c88a5d" class="margin-toggle"/><span class="sidenote"><mathjax>$A_{i,j,d}$</mathjax>  can also be used for computing the first task, but we will need both <mathjax>$W_{i,j,d}$</mathjax> and <mathjax>$A_{i,j,d}$</mathjax> so it doesn’t matter which one we will use.</span></p><p>What we are going to do will be similar to the naive way. We will try removing each block at a time in the map and evaluate how many initial configurations that will lead to a treasure box changes after the removal. However, we will not call the algorithm in the first task on the modified map. Instead, we will use the exactly same data from the first task that we have already to compute the answer.</p><p>Consider removing a block, say <mathjax>$(h, k)$</mathjax> where <mathjax>$h \in \{1,2,...,r\}, k \in \{1,2,...,c\}$</mathjax>. What is the impact? It definitely doesn’t impact Lemmo that will not step on block <mathjax>$(h, k)$</mathjax> in its travelling, since the map is otherwise the same. So, we only need to care about Lemmo which would step on <mathjax>$(h, k)$</mathjax>. Say, in the old map Lemmo at <mathjax>$(h, k, L)$</mathjax> will end up at <mathjax>$T_5$</mathjax>, but after the removal of the block, it will end up at <mathjax>$T_3$</mathjax>. But as mentioned before, this is too detailed. We don’t care where Lemmo will end up exactly. Since in the old map Lemmo at <mathjax>$(h, k, L)$</mathjax> will end up with a <mathjax>$T$</mathjax> and in the new map it will end up with a <mathjax>$T$</mathjax> too, this has no impact.</p><p>So a removal of a block will have an impact when <mathjax>$A_{h,k,d} \ne A_{h+1,k,d}$</mathjax>, where <mathjax>$A_{h,k,d}$</mathjax> indicates the eventual status of Lemmo stepping on the removed block in the old map (where the block is not removed yet), and <mathjax>$A_{h+1,k,d}$</mathjax> indicates the evantual status of Lemmo stepping on a block below the removed block in the old map, which is the same as stepping on the removed block in the new map and then fall to the below. The impact is positive when <mathjax>$A_{h,k,d} = F$</mathjax> and <mathjax>$A_{h+1,k,d} = T$</mathjax> because it means previously in the old map, Lemmo would not find a treasure, but in the new map it will. The impact is negative when <mathjax>$A_{h,k,d} = T$</mathjax> and <mathjax>$A_{h+1,k,d} = F$</mathjax>.</p><p>But this still doesn’t give us an answer. We want to know the delta of number of ways to reach a treasure box. Let <mathjax>$N_{h,k,d}$</mathjax> indicates the number of ways that Lemmo will reach <mathjax>$(h,k,d)$</mathjax> in the <i>new</i> map (after removing block <mathjax>$(h,k)$</mathjax>). The delta on a direction <mathjax>$d$</mathjax> then would be <mathjax>$N_{h,k,d}$</mathjax> when the impact is positive, <mathjax>$-N_{h,k,d}$</mathjax> when the impact is negative, or <mathjax>$0$</mathjax> otherwise. This partially corresponds to line 62 and 64 (continue reading the next paragraphs for a complete explanation). The total delta is the sum of these two directional deltas. And we just need to find <mathjax>$(h, k)$</mathjax> that will maximize this delta. This corresponds to line 84.</p><p>How do we compute <mathjax>$N_{h,k,d}$</mathjax>? Let’s see... Try the following map where <code>!</code> indicates the removed block.</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="source"><pre><span></span>+---------------------------
|  .   .   .   .   .   .   .
|
|  #############.###########
|             ←
|  ...###...##!###...###....
|
|  .   .   .   .   .   .   .
</pre></div></td></tr></tbody></table></div><p>The number of ways to get to <code>←</code> in the new map is merely the number of ways to get to <code>←</code> in the old map! That is, <mathjax>$N_{h,k,d} = W_{h,k,d}$</mathjax>!</p><p>Right?</p><p>This is almost true, but it is unfortunately false in some rare cases. Since the change occurs on row <mathjax>$h$</mathjax>, it won’t impact rows above <mathjax>$h$</mathjax>. If we were to compute <mathjax>$N_{h,k,d}$</mathjax> using dynamic programming, it would agree on <mathjax>$W$</mathjax> until row <mathjax>$h - 1$</mathjax>. So far so good. Then Lemmo walks and steps on <mathjax>$(h,k)$</mathjax>. Normally, in the old map it would just walk past <mathjax>$(h,k)$</mathjax> and then fall to the below floor <i>without revisiting <mathjax>$(h,k)$</mathjax> again</i>, as shown in the above map. Therefore, <mathjax>$N_{h,k,d} = W_{h,k,d}$</mathjax>. However, this is not always the case. Consider:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="source"><pre><span></span>+---------------------------
|  .   .   .   .   .   .   .
|
|  #############.########.##
|                      ←
|  ...###...###########!####
|
|  .   .   .   .   .   .   .
</pre></div></td></tr></tbody></table></div><p>Here, <mathjax>$N_{h,k,L} \ne W_{h,k,L}$</mathjax> because <mathjax>$W_{h,k,L}$</mathjax> includes the situation when Lemmo steps on <mathjax>$(h,k)$</mathjax> facing into the right wall, then bounce off the right wall, and step over <mathjax>$(h,k)$</mathjax> again, this time facing out of the right wall. However, <mathjax>$N_{h,k,L}$</mathjax> can’t include this kind of situation because if the block is removed, Lemmo would fall to the below floor already when it steps on <mathjax>$(h,k)$</mathjax> at the first time.</p><p>Now we know exactly when will this weird rare case happens: when Lemmo faces out of a wall, and would have just bounced off from the wall. That is, there are contiguous blocks starting from the <mathjax>$(h,k)$</mathjax> to the wall. There are now two questions:</p><ul><li><p>How do we detect this special case efficiently?</p><p>the naive way would be looping from <mathjax>$(h,k)$</mathjax> to the wall and see if they are all blocks. However, number of blocks in a floor is in the order of <mathjax>$O(c)$</mathjax>. We need to try removing all blocks where the number of all blocks are in the order of <mathjax>$O(rc)$</mathjax> already, so this would result in <mathjax>$O(rc^2)$</mathjax> which is too slow.</p><p>And, you know how this will go: dynamic programming! They are all blocks if the current position is a block and the rest are all blocks. I in fact make it even simpler by observing the following: Let’s say we maps <code>#</code> to 1 and <code>.</code> to 0.</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span></span>##..###..#.####
</pre></div></td></tr></tbody></table></div><p>would then be the following array <mathjax>$B$</mathjax>:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span></span>1 1 0 0 1 1 1 0 0 1 0 1 1 1 1
</pre></div></td></tr></tbody></table></div><p>To see if it’s all blocks from the third position from the right to the right wall, we need to see if they are all 1s. That is, if <mathjax>$B_{13} + B_{14} + B_{15} = 1 + 1 + 1 \stackrel{?}{=} 3$</mathjax>, and in this case, it does, so it’s all blocks.</p><p>Let’s try another one. We want to see if the fourth position from the left to the left wall are all blocks or not. That is, if <mathjax>$B_1 + B_2 + B_3 + B_4 = 1 + 1 + 0 + 0 \stackrel{?}{=} 4$</mathjax>, and the answer is no, so it’s not all blocks.</p><p>But we still need to loop over to compute the sum of numbers! How is that gonna make a difference?</p><p>Let’s construct a prefix-sum table <mathjax>$E$</mathjax> which in this case would be</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span></span>1 2 2 2 3 4 5 5 5 6 6 7 8 9 10
</pre></div></td></tr></tbody></table></div><p>That is, <mathjax>$E_k = \sum_{i = 1}^k B_i$</mathjax>. And by rewriting it to be in dynamic programming style, we obtain: <mathjax>$E_k = \sum_{i = 1}^{k-1} B_i + B_k = E_{k - 1} + B_k$</mathjax>, where <mathjax>$E_0 = 0$</mathjax>.</p><p>Then, <mathjax>$B_i + ... + B_j = \left(B_1 + ... + B_{i - 1} + (B_i + ... + B_j)\right) - (B_1 + ... + B_{i - 1})$</mathjax>. That is, <mathjax>$B_i + ... + B_j = E_j - E_{i - 1}$</mathjax>.</p><p>So detecting this special case can be done in <mathjax>$O(1)$</mathjax> (provided that the prefix-sum is already constructed)!</p><p>Building the prefix-sum table corresponds to line 16. Checking if it’s all blocks corresponds to function <code>has-all?</code> in line 29.</p></li><li><p>How do we cope with it?</p><p>Well, if we know that it’s a special case, then we know that <mathjax>$W_{h,k,d}$</mathjax> overcounts, because it includes <mathjax>$W_{h,k,d’}$</mathjax> where <mathjax>$d$</mathjax> is the direction facing out of the wall, and <mathjax>$d’$</mathjax> is the direction facing in the wall. Therefore, <mathjax>$N_{h,k,d}$</mathjax> is just <mathjax>$W_{h,k,d} - W_{h,k,d’}$</mathjax>. This corresponds to line 71.</p></li></ul><p>The second task only needs to compute the table <mathjax>$A$</mathjax> and the prefix-sum table. Just like the first task, both of these can be done in <mathjax>$O(rc)$</mathjax> (one is a direct table-filling dynamic programming, and the other is memoization).</p><p>With these, we are able to compute the answer to the second task in <mathjax>$O(rc)$</mathjax>.</p><p>FIN <i class="em em-smiley"></i></p></div><div class="see-more-link"><a href="/blog/2016-12-27-lemmo.html"><span class="smallcaps">[see more]</span></a></div><hr/>
    </div>
  </section>
</body>
</html>