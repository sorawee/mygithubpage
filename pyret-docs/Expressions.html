<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.6&nbsp;Expressions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="editor.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins.html" class="tocviewlink" data-pltdoc="x">Builtins</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Libraries.html" class="tocviewlink" data-pltdoc="x">Libraries</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Internals.html" class="tocviewlink" data-pltdoc="x">Internals</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="Statements.html" class="tocviewlink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.6.1&nbsp;</td><td><a href="#%28part._s~3alam-expr%29" class="tocviewlink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td align="right">2.1.6.2&nbsp;</td><td><a href="#%28part._s~3aapp-expr%29" class="tocviewlink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td align="right">2.1.6.3&nbsp;</td><td><a href="#%28part._s~3acurried-apply-expr%29" class="tocviewlink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td align="right">2.1.6.4&nbsp;</td><td><a href="#%28part._s~3acannonball-expr%29" class="tocviewlink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td align="right">2.1.6.5&nbsp;</td><td><a href="#%28part._s~3abinop-expr%29" class="tocviewlink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td align="right">2.1.6.6&nbsp;</td><td><a href="#%28part._s~3aobj-expr%29" class="tocviewlink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td align="right">2.1.6.7&nbsp;</td><td><a href="#%28part._s~3adot-expr%29" class="tocviewlink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td align="right">2.1.6.8&nbsp;</td><td><a href="#%28part._s~3aextend-expr%29" class="tocviewlink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td align="right">2.1.6.9&nbsp;</td><td><a href="#%28part._s~3aif-expr%29" class="tocviewlink" data-pltdoc="x">If Expressions</a></td></tr><tr><td align="right">2.1.6.10&nbsp;</td><td><a href="#%28part._s~3aask-expr%29" class="tocviewlink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td align="right">2.1.6.11&nbsp;</td><td><a href="#%28part._s~3acases-expr%29" class="tocviewlink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td align="right">2.1.6.12&nbsp;</td><td><a href="#%28part._s~3afor-expr%29" class="tocviewlink" data-pltdoc="x">For Expressions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.6.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alam-expr%29" class="tocsubseclink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.2<tt>&nbsp;</tt></span><a href="#%28part._s~3aapp-expr%29" class="tocsubseclink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.3<tt>&nbsp;</tt></span><a href="#%28part._s~3acurried-apply-expr%29" class="tocsubseclink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.4<tt>&nbsp;</tt></span><a href="#%28part._s~3acannonball-expr%29" class="tocsubseclink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.5<tt>&nbsp;</tt></span><a href="#%28part._s~3abinop-expr%29" class="tocsubseclink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.6<tt>&nbsp;</tt></span><a href="#%28part._s~3aobj-expr%29" class="tocsubseclink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.7<tt>&nbsp;</tt></span><a href="#%28part._s~3adot-expr%29" class="tocsubseclink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.8<tt>&nbsp;</tt></span><a href="#%28part._s~3aextend-expr%29" class="tocsubseclink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.9<tt>&nbsp;</tt></span><a href="#%28part._s~3aif-expr%29" class="tocsubseclink" data-pltdoc="x">If Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.10<tt>&nbsp;</tt></span><a href="#%28part._s~3aask-expr%29" class="tocsubseclink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.11<tt>&nbsp;</tt></span><a href="#%28part._s~3acases-expr%29" class="tocsubseclink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.12<tt>&nbsp;</tt></span><a href="#%28part._s~3afor-expr%29" class="tocsubseclink" data-pltdoc="x">For Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.5 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.7 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.6<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h5><h5>2.1.6.1<tt>&nbsp;</tt><a name="(part._s~3alam-expr)"></a>Lambda Expressions</h5><p>The grammar for a lambda expression is:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lambda-expr: "lam" ty-params [args] return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">doc-string</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">where-clause</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">fun-header: ty-params NAME args return-ann</span></p></td></tr><tr><td><p><span class="stt">ty-params:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["&lt;" list-ty-param* NAME "&gt;"]</span></p></td></tr><tr><td><p><span class="stt">list-ty-param: NAME ","</span></p></td></tr><tr><td><p><span class="stt">args: (PARENSPACE|PARENNOSPACE) [list-arg-elt* binding] ")"</span></p></td></tr><tr><td><p><span class="stt">list-arg-elt: binding ","</span></p></td></tr><tr><td><p><span class="stt">return-ann: ["-&gt;" ann]</span></p></td></tr><tr><td><p><span class="stt">doc-string: ["doc:" STRING]</span></p></td></tr></table></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The <span class="stt">ty-params</span> and <span class="stt">where-clause</span> of lambda expressions are currently not
interpreted by Pyret.  The <span class="stt">ty-params</span> will be used when Pyret has more
complete support for checking polymorphic functions.  The <span class="stt">where-clause</span> is
included for homogeneity with <a href="Statements.html#%28part._s~3afun-expr%29" data-pltdoc="x">function statements</a>.</p></blockquote></blockquote></blockquote><p>A lambda expression creates a function value that can be applied with
<a href="#%28part._s~3aapp-expr%29" data-pltdoc="x">application expressions</a>.  The arguments in <span class="stt">args</span>
are bound to their arguments as immutable identifiers as in a
<a href="Statements.html#%28part._s~3alet-expr%29" data-pltdoc="x">let expression</a>.  These identifiers follow the same
rules of no shadowing and no assignment.</p><p>If the arguments have <a href="s_annotations.html" data-pltdoc="x">annotations</a> associated with
them, they are checked before the body of the function starts evaluating, in
order from left to right.  If an annotation fails, an exception is thrown.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">add1 = lam(x :: Number):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">x + 1</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt">add1("not-a-number")</span></p></td></tr><tr><td><p><span class="stt"># Error: expected a Number and got "not-a-number"</span></p></td></tr></table></blockquote><h5>2.1.6.2<tt>&nbsp;</tt><a name="(part._s~3aapp-expr)"></a>Application Expressions</h5><p>Function application expressions have the following grammar:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">app-expr: expr app-args</span></p></td></tr><tr><td><p><span class="stt">app-args: PARENNOSPACE [app-arg-elt* binop-expr] ")"</span></p></td></tr><tr><td><p><span class="stt">app-arg-elt: binop-expr ","</span></p></td></tr></table></blockquote><p>An application expression is an expression (usually expected to evaluate to a
function), followed by a comma-separated list of arguments enclosed in
parentheses.  It first evaluates the arguments in left-to-right order, then
evaluates the function position.  If the function position is a function value,
the number of provided arguments is checked against the number of arguments
that the function expects.  If they match, the arguments names are bound to the
provided values.  If they don&rsquo;t, an exception is thrown.</p><p>Note that there is <span style="font-style: italic">no space</span> allowed before the opening parenthesis of
the application.  If you make a mistake, Pyret will complain:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">f(1) # This is the function application expression f(1)</span></p></td></tr><tr><td><p><span class="stt">f (1) # This is the id-expr f, followed by the paren-expr (1)</span></p></td></tr><tr><td><p><span class="stt"># The second form yields a well-formedness error that there</span></p></td></tr><tr><td><p><span class="stt"># are two expressions on the same line</span></p></td></tr></table></blockquote><h5>2.1.6.3<tt>&nbsp;</tt><a name="(part._s~3acurried-apply-expr)"></a>Curried Application Expressions</h5><p>Suppose a function is defined with multiple arguments:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun f(v, w, x, y, z): ... end</span></p></td></tr></table></blockquote><p>Sometimes, it is particularly convenient to define a new function that
calls <span class="stt">f</span> with some arguments pre-specified:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">call-f-with-123 = lam(y, z): f(1, 2, 3, y, z) end</span></p></td></tr></table></blockquote><p>Pyret provides syntactic sugar to make writing such helper functions
easier:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">call-f-with-123 = f(1, 2, 3, _, _) # same as the fun expression above</span></p></td></tr></table></blockquote><p>Specifically, when Pyret code contains a function application some of
whose arguments are underscores, it constructs an anonymous function
with the same number of arguments as there were underscores in the
original expression, whose body is simply the original function
application, with the underscores replaced by the names of the
arguments to the anonymous function.</p><p>This syntactic sugar also works
with operators.  For example, the following are two ways to sum a list
of numbers:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">[list: 1, 2, 3, 4].foldl(lam(a, b): a + b end, 0)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">[list: 1, 2, 3, 4].foldl(_ + _, 0)</span></p></td></tr></table></blockquote><p>Likewise, the following are two ways to compare two lists for
equality:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">list.map_2(lam(x, y): x == y end, first-list, second-list)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">list.map_2(_ == _, first-list, second-list)</span></p></td></tr></table></blockquote><p>Note that there are some limitations to this syntactic sugar.  You
cannot use it with the <span class="stt">is</span> or <span class="stt">raises</span> expressions in
check blocks, since both test expressions and expected
outcomes are known when writing tests.  Also, note that the sugar is
applied only to one function application at a time.  As a result, the
following code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">_ + _ + _</span></p></td></tr></table></blockquote><p>desugars to</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lam(z):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(fun (x, y): x + y end) + z</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>which is probably not what was intended.  You can still write the
intended expression manually:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lam(x, y, z): x + y + z end</span></p></td></tr></table></blockquote><p>Pyret just does not provide syntactic sugar to help in this case
(or other more complicated ones).</p><h5>2.1.6.4<tt>&nbsp;</tt><a name="(part._s~3acannonball-expr)"></a>Chaining Application</h5><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">CARET: "^"</span></p></td></tr><tr><td><p><span class="stt">chain-app-expr: binop-expr CARET binop-expr</span></p></td></tr></table></blockquote><p>The expression <span class="pyret-highlight"><span class="stt">e1 ^ e2</span></span> is equivalent to <span class="pyret-highlight"><span class="stt">e2(e1)</span></span>.  It&rsquo;s just
another way of writing a function application to a single argument.</p><p>Sometimes, composing functions doesn&rsquo;t produce readable code.  For example, if
say we have a <span class="pyret-highlight"><span class="stt">Tree</span></span> datatype, and we have an <span class="pyret-highlight"><span class="stt">add</span></span> operation on
it, defined via a function.  To build up a tree with a series of adds, we&rsquo;d
write something like:</p><pre class="pyret-highlight"><p>t = add(add(add(add(empty-tree, 1), 2), 3), 4)</p></pre><p>Or maybe</p><pre class="pyret-highlight"><p>t1 = add(empty-tree, 1)
t2 = add(t1, 2)
t3 = add(t2, 3)
t  = add(t3, 4)</p></pre><p>If <span class="pyret-highlight"><span class="stt">add</span></span> were a method, we could write:</p><pre class="pyret-highlight"><p>t = empty-tree.add(1).add(2).add(3).add(4)</p></pre><p>which would be more readable, but since <span class="pyret-highlight"><span class="stt">add</span></span> is a function, this doesn&rsquo;t
work.</p><p>In this case, we can write instead:</p><pre class="pyret-highlight"><p>t = empty-tree ^ add(_, 1) ^ add(_, 2) ^ add(_, 3)</p></pre><p>This uses <a href="#%28part._s~3acurried-apply-expr%29" data-pltdoc="x">curried application</a> to create a
single argument function, and chaining application to apply it.  This can be
more readable across several lines of initialization as well, when compared to
composing &#8220;inside-out&#8221; or using several intermediate names:</p><pre class="pyret-highlight"><p>t = empty-tree
  ^ add(_, 1)
  ^ add(_, 2)
  ^ add(_, 3)
  # and so on</p></pre><h5>2.1.6.5<tt>&nbsp;</tt><a name="(part._s~3abinop-expr)"></a>Binary Operators</h5><p>There are a number of binary operators in Pyret.  A binary operator expression
is written by putting an operator between two other expressions, as in:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">binop-expr: binop-expr BINOP binop-expr</span></p></td></tr></table></blockquote><p>Each binary operator is syntactic sugar for a particular method or function
call.  The following table lists the operators, their intended use, and the
corresponding call:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">left + right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._plus(right)</span></p></td></tr><tr><td><p><span class="stt">left - right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._minus(right)</span></p></td></tr><tr><td><p><span class="stt">left * right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._times(right)</span></p></td></tr><tr><td><p><span class="stt">left / right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._divide(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessthan(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterthan(right)</span></p></td></tr></table></p><p>For the primitive strings and numbers, the operation happens internally.  For
all object values, the operator looks for the method appropriate method and
calls it.  The special names allow a form of operator overloading, and avoid
adding an extra concept beyond function and method calls to the core to
account for these binary operations.</p><h5>2.1.6.6<tt>&nbsp;</tt><a name="(part._s~3aobj-expr)"></a>Object Expressions</h5><p>Object expressions map field names to values:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">obj-expr: "{" fields "}" | "{" "}"</span></p></td></tr><tr><td><p><span class="stt">fields: list-field* field [","]</span></p></td></tr><tr><td><p><span class="stt">list-field: field ","</span></p></td></tr><tr><td><p><span class="stt">field: key ":" binop-expr</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| key args return-ann ":" doc-string block where-clause "end"</span></p></td></tr><tr><td><p><span class="stt">key: NAME</span></p></td></tr></table></blockquote><p>A comma-separated sequence of fields enclosed in <span class="stt">{}</span> creates an object; we
refer to the expression as an <span style="font-style: italic">object literal</span>.  There are two types of
fields: <span style="font-style: italic">data</span> fields and <span style="font-style: italic">method</span> fields.  A data field in an object
literal simply creates a field with that name on the resulting object, with its
value equal to the right-hand side of the field.  A method field</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">key args return-ann ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">key ":" "method" args return-ann ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>That is, it&rsquo;s just special syntax for a data field that contains a method
value.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The overriding of later fields is expected to be deprecated and
replaced with an error.</p></blockquote></blockquote></blockquote><p>The fields are evaluated in order.  If the same field appears more than once,
the later use overrides the earlier use, but both field expressions are still
evaluated.</p><h5>2.1.6.7<tt>&nbsp;</tt><a name="(part._s~3adot-expr)"></a>Dot Expressions</h5><p>A dot expression is any expression, followed by a dot and name:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">dot-expr: expr "." NAME</span></p></td></tr></table></blockquote><p>A dot expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then does one
of five things:</p><ul><li><p>Raises an exception, if <span class="stt">NAME</span> is not a field of <span class="stt">expr</span></p></li><li><p>Evaluates to the value stored in <span class="stt">NAME</span>, if <span class="stt">NAME</span> is present and
not a method</p></li><li><p>If the <span class="stt">NAME</span> field is a method value, evaluates to a function that is
the <span style="font-style: italic">method binding</span> of the method value to <span class="stt">val</span>.  For a method</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">m = method(self, x): body end</span></p></td></tr></table></blockquote><p>The <span style="font-style: italic">method binding</span> of <span class="stt">m</span> to a value <span class="stt">v</span> is equivalent to:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(lam(self): lam(x): body end end)(v)</span></p></td></tr></table></blockquote><p>What this detail means is that you can look up a method and it
automatically closes over the value on the left-hand side of the dot.  This
bound method can be freely used as a function.</p><p>For example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">o = { m(self, x): self.y + x end, y: 22 }</span></p></td></tr><tr><td><p><span class="stt">check:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">the-m-method-closed-over-o = o.m</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">the-m-method-closed-over-o(5) is 27</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote></li></ul><h5>2.1.6.8<tt>&nbsp;</tt><a name="(part._s~3aextend-expr)"></a>Extend Expressions</h5><p>The extend expression consists of an base expression and a list of fields to
extend it with:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">extend-expr: expr "." "{" fields "}"</span></p></td></tr></table></blockquote><p>The extend expression first evaluates <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
creates a new object with all the fields of <span class="stt">val</span> and <span class="stt">fields</span>.  If a
field is present in both, the new field is used.</p><p>Examples:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">check:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o = {x : "original-x", y: "original-y"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2 = o.{x : "new-x", z : "new-z"}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.x is "new-x"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.y is "original-y"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">o2.z is "new-z"</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><h5>2.1.6.9<tt>&nbsp;</tt><a name="(part._s~3aif-expr)"></a>If Expressions</h5><p>An if expression has a number of test conditions and an optional else case.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">if-expr: IF binop-expr COLON block else-if* [ELSECOLON block] end</span></p></td></tr><tr><td><p><span class="stt">else-if: ELSEIF binop-expr COLON block</span></p></td></tr></table></blockquote><p>For example, this if expression has an "else:"</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre><p>This one does not:</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
end</p></pre><p>Both are valid.  The conditions are tried in order, and the block corresponding
to the first one to return <span class="pyret-highlight"><span class="stt">true</span></span> is evaluated.  If no condition matches,
the else branch is evaluated if present.  If no condition matches and no else
branch is present, an error is thrown.  If a condition evaluates to a value
other than <span class="pyret-highlight"><span class="stt">true</span></span> or <span class="pyret-highlight"><span class="stt">false</span></span>, a runtime error is thrown.</p><h5>2.1.6.10<tt>&nbsp;</tt><a name="(part._s~3aask-expr)"></a>Ask Expressions</h5><p>An <span class="pyret-highlight"><span class="stt">ask</span></span> expression is a different way of writing an <span class="pyret-highlight"><span class="stt">if</span></span>
expression that can be easier to read in some cases.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">ask-expr: ASKCOLON ask-branch* [BAR OTHERWISECOLON block] end</span></p></td></tr><tr><td><p><span class="stt">ask-branch: BAR binop-expr THENCOLON block</span></p></td></tr></table></blockquote><p>This ask expression:</p><pre class="pyret-highlight"><p>ask:
  | x == 0 then: 1
  | x &gt; 0 then: x
  | otherwise: x * -1
end</p></pre><p>is equivalent to</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre><p>Similar to <span class="pyret-highlight"><span class="stt">if</span></span>, if an <span class="pyret-highlight"><span class="stt">otherwise:</span></span> branch isn&rsquo;t specified and no
branch matches, a runtime error results.</p><h5>2.1.6.11<tt>&nbsp;</tt><a name="(part._s~3acases-expr)"></a>Cases Expressions</h5><p>A cases expression consists of a datatype (in parentheses), an expression to
inspect (before the colon), and a number of branches.  It is intended to be
used in a structure parallel to a data definition.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">cases-expr: "cases" (PARENSPACE|PARENNOSPACE) check-ann ")" expr-target ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">cases-branch*</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">["|" "else" "=&gt;" block]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">cases-branch: "|" NAME [args] "=&gt;" block</span></p></td></tr></table></blockquote><p>The <span class="pyret-highlight"><span class="stt">check-ann</span></span> must be a type, like <a href="lists.html#%28part._lists_.List%29" data-pltdoc="x"><span class="stt">List</span></a>.  Then
<span class="pyret-highlight"><span class="stt">expr-target</span></span> is evaluated and checked against the given annotation.  If
it has the right type, the cases are then checked.</p><p>Cases should use the names of the variants of the given data type as the
<span class="stt">NAME</span>s of each branch.  In the branch that matches, the fields of the
variant are bound, in order, to the provided <span class="stt">args</span>, and the right-hand side
of the <span class="stt">=&gt;</span> is evaluated in that extended environment.  An exception results
if the wrong number of arguments are given.</p><p>An optional <span class="stt">else</span> clause can be provided, which is evaluated if no cases
match.  If no <span class="stt">else</span> clause is provided, a default is used that raises an
exception.</p><p>For example, some cases expression on lists looks like:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">check:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result = cases(List) [list: 1,2,3]:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| empty =&gt; "empty"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| link(f, r) =&gt; "link"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result is "link"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result2 = cases(List) [list: 1,2,3]:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| empty =&gt; "empty"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| else =&gt; "else"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result2 is else</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result3 = cases(List) empty:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| empty =&gt; "empty"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| else =&gt; "else"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result3 is "empty"</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><h5>2.1.6.12<tt>&nbsp;</tt><a name="(part._s~3afor-expr)"></a>For Expressions</h5><p>For expressions consist of the <span class="stt">for</span> keyword, followed by a list of
<span class="stt">binding from expr</span> clauses in parentheses, followed by a block:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">for-expr: "for" expr PARENNOSPACE [for-bind-elt* for-bind] ")" return-ann ":"</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt">"end"</span></p></td></tr><tr><td><p><span class="stt">for-bind-elt: for-bind ","</span></p></td></tr><tr><td><p><span class="stt">for-bind: binding "from" binop-expr</span></p></td></tr></table></blockquote><p>The for expression is just syntactic sugar for a
<a href="#%28part._s~3alam-expr%29" data-pltdoc="x"><span class="stt">lam-expr</span></a> and a <a href="#%28part._s~3aapp-expr%29" data-pltdoc="x"><span class="stt">app-expr</span></a>.  An expression</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">for fun-expr(arg1 :: ann1 from expr1, ...) -&gt; ann-return:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">block</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr></table></blockquote><p>is equivalent to:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fun-expr(lam(arg1 :: ann1, ...) -&gt; ann-return: block end, expr1, ...)</span></p></td></tr></table></blockquote><p>Using a <span class="stt">for-expr</span> can be a more natural way to call, for example, list
iteration functions because it puts the identifier of the function and the
value it draws from closer to one another.  Use of <span class="stt">for-expr</span> is a matter of
style; here is an example that compares <span class="stt">fold</span> with and without <span class="stt">for</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">for fold(sum from 0, number from [list: 1,2,3,4]):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">sum + number</span></p></td></tr><tr><td><p><span class="stt">end</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">fold(lam(sum, number): sum + number end, 0, [list: 1,2,3,4])</span></p></td></tr></table></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.5 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.7 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>