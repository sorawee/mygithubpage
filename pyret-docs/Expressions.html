<!doctype HTML>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<script src="runmode.js"></script>
<script src="pyret.js"></script>
<script src="hilite.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>2.1.6&nbsp;Expressions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><link rel="stylesheet" type="text/css" href="pyret.css" title="default"/><link rel="stylesheet" type="text/css" href="styles.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Pyret</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Getting_Started.html" class="tocviewlink" data-pltdoc="x">Getting Started</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewselflink" data-pltdoc="x">Language Concepts</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Builtins.html" class="tocviewlink" data-pltdoc="x">Builtins</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Libraries.html" class="tocviewlink" data-pltdoc="x">Libraries</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="Language_Concepts.html" class="tocviewlink" data-pltdoc="x">Language Concepts</a></td></tr></table><div class="tocviewsublist" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewselflink" data-pltdoc="x">Language Constructs</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="testing.html" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="equality.html" class="tocviewlink" data-pltdoc="x">equality</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="brands.html" class="tocviewlink" data-pltdoc="x">Brands</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9660;</a></td><td>2.1&nbsp;</td><td><a href="s_forms.html" class="tocviewlink" data-pltdoc="x">Language Constructs</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.1&nbsp;</td><td><a href="s_program.html" class="tocviewlink" data-pltdoc="x">Programs</a></td></tr><tr><td align="right">2.1.2&nbsp;</td><td><a href="Import_Statements.html" class="tocviewlink" data-pltdoc="x">Import Statements</a></td></tr><tr><td align="right">2.1.3&nbsp;</td><td><a href="Provide_Statements.html" class="tocviewlink" data-pltdoc="x">Provide Statements</a></td></tr><tr><td align="right">2.1.4&nbsp;</td><td><a href="Blocks.html" class="tocviewlink" data-pltdoc="x">Blocks</a></td></tr><tr><td align="right">2.1.5&nbsp;</td><td><a href="Statements.html" class="tocviewlink" data-pltdoc="x">Statements</a></td></tr><tr><td align="right">2.1.6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.1.7&nbsp;</td><td><a href="s_annotations.html" class="tocviewlink" data-pltdoc="x">Annotations</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_3&quot;);">&#9658;</a></td><td>2.1.6&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Expressions</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_3"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1.6.1&nbsp;</td><td><a href="#%28part._s~3alam-expr%29" class="tocviewlink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td align="right">2.1.6.2&nbsp;</td><td><a href="#%28part._s~3aapp-expr%29" class="tocviewlink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td align="right">2.1.6.3&nbsp;</td><td><a href="#%28part._s~3acurried-apply-expr%29" class="tocviewlink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td align="right">2.1.6.4&nbsp;</td><td><a href="#%28part._s~3acannonball-expr%29" class="tocviewlink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td align="right">2.1.6.5&nbsp;</td><td><a href="#%28part._s~3abinop-expr%29" class="tocviewlink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td align="right">2.1.6.6&nbsp;</td><td><a href="#%28part._s~3aobj-expr%29" class="tocviewlink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td align="right">2.1.6.7&nbsp;</td><td><a href="#%28part._s~3adot-expr%29" class="tocviewlink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td align="right">2.1.6.8&nbsp;</td><td><a href="#%28part._s~3aextend-expr%29" class="tocviewlink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td align="right">2.1.6.9&nbsp;</td><td><a href="#%28part._s~3aif-expr%29" class="tocviewlink" data-pltdoc="x">If Expressions</a></td></tr><tr><td align="right">2.1.6.10&nbsp;</td><td><a href="#%28part._s~3aask-expr%29" class="tocviewlink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td align="right">2.1.6.11&nbsp;</td><td><a href="#%28part._s~3acases-expr%29" class="tocviewlink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td align="right">2.1.6.12&nbsp;</td><td><a href="#%28part._s~3afor-expr%29" class="tocviewlink" data-pltdoc="x">For Expressions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1.6.1<tt>&nbsp;</tt></span><a href="#%28part._s~3alam-expr%29" class="tocsubseclink" data-pltdoc="x">Lambda Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.2<tt>&nbsp;</tt></span><a href="#%28part._s~3aapp-expr%29" class="tocsubseclink" data-pltdoc="x">Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.3<tt>&nbsp;</tt></span><a href="#%28part._s~3acurried-apply-expr%29" class="tocsubseclink" data-pltdoc="x">Curried Application Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.4<tt>&nbsp;</tt></span><a href="#%28part._s~3acannonball-expr%29" class="tocsubseclink" data-pltdoc="x">Chaining Application</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.5<tt>&nbsp;</tt></span><a href="#%28part._s~3abinop-expr%29" class="tocsubseclink" data-pltdoc="x">Binary Operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.6<tt>&nbsp;</tt></span><a href="#%28part._s~3aobj-expr%29" class="tocsubseclink" data-pltdoc="x">Object Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.7<tt>&nbsp;</tt></span><a href="#%28part._s~3adot-expr%29" class="tocsubseclink" data-pltdoc="x">Dot Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.8<tt>&nbsp;</tt></span><a href="#%28part._s~3aextend-expr%29" class="tocsubseclink" data-pltdoc="x">Extend Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.9<tt>&nbsp;</tt></span><a href="#%28part._s~3aif-expr%29" class="tocsubseclink" data-pltdoc="x">If Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.10<tt>&nbsp;</tt></span><a href="#%28part._s~3aask-expr%29" class="tocsubseclink" data-pltdoc="x">Ask Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.11<tt>&nbsp;</tt></span><a href="#%28part._s~3acases-expr%29" class="tocsubseclink" data-pltdoc="x">Cases Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6.12<tt>&nbsp;</tt></span><a href="#%28part._s~3afor-expr%29" class="tocsubseclink" data-pltdoc="x">For Expressions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.5 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.7 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h5>2.1.6<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions</h5><p>The following are all the expression forms of Pyret:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._expr)))"></a>&#8249;expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._paren-expr%29%29%29" data-pltdoc="x">&#8249;paren-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._id-expr%29%29%29" data-pltdoc="x">&#8249;id-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._prim-expr%29%29%29" data-pltdoc="x">&#8249;prim-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._lambda-expr%29%29%29" data-pltdoc="x">&#8249;lambda-expr&#8250;</a><span class="bnf-meta"> | </span><font class="badlink">&#8249;method-expr&#8250;</font><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._app-expr%29%29%29" data-pltdoc="x">&#8249;app-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._obj-expr%29%29%29" data-pltdoc="x">&#8249;obj-expr&#8250;</a><span class="bnf-meta"> | </span><font class="badlink">&#8249;tuple-expr&#8250;</font><span class="bnf-meta"> | </span><font class="badlink">&#8249;tuple-get&#8250;</font>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._dot-expr%29%29%29" data-pltdoc="x">&#8249;dot-expr&#8250;</a>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;template-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;get-bang-expr&#8250;</font><span class="bnf-meta"> | </span><font class="badlink">&#8249;update-expr&#8250;</font>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._extend-expr%29%29%29" data-pltdoc="x">&#8249;extend-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._if-expr%29%29%29" data-pltdoc="x">&#8249;if-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._ask-expr%29%29%29" data-pltdoc="x">&#8249;ask-expr&#8250;</a><span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._cases-expr%29%29%29" data-pltdoc="x">&#8249;cases-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="#%28elem._%28bnf-prod._%28.Pyret._for-expr%29%29%29" data-pltdoc="x">&#8249;for-expr&#8250;</a>
        <span class="bnf-meta"> | </span><a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._user-block-expr%29%29%29" data-pltdoc="x">&#8249;user-block-expr&#8250;</a><span class="bnf-meta"> | </span><font class="badlink">&#8249;inst-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;multi-let-expr&#8250;</font><span class="bnf-meta"> | </span><font class="badlink">&#8249;letrec-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;type-let-expr&#8250;</font>
        <span class="bnf-meta"> | </span><font class="badlink">&#8249;construct-expr&#8250;</font>
<a name="(elem._(bnf-prod._(.Pyret._paren-expr)))"></a>&#8249;paren-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._id-expr)))"></a>&#8249;id-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span>
<a name="(elem._(bnf-prod._(.Pyret._prim-expr)))"></a>&#8249;prim-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NUMBER</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">RATIONAL</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">BOOLEAN</span><span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">STRING</span></p></blockquote><h5>2.1.6.1<tt>&nbsp;</tt><a name="(part._s~3alam-expr)"></a>Lambda Expressions</h5><p>The grammar for a lambda expression is:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._lambda-expr)))"></a>&#8249;lambda-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">lam</span> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-lit">:</span> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span></p></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The <span class="stt">ty-params</span> and <span class="stt">where-clause</span> of lambda expressions are currently not
interpreted by Pyret.  The <span class="stt">ty-params</span> will be used when Pyret has more
complete support for checking polymorphic functions.  The <span class="stt">where-clause</span> is
included for homogeneity with <a href="Statements.html#%28part._s~3afun-expr%29" data-pltdoc="x">function statements</a>.</p></blockquote></blockquote></blockquote><p>A lambda expression creates a function value that can be applied with
<a href="#%28part._s~3aapp-expr%29" data-pltdoc="x">application expressions</a>.  The arguments in <span class="stt">args</span>
are bound to their arguments as immutable identifiers as in a
<a href="Statements.html#%28part._s~3alet-expr%29" data-pltdoc="x">let expression</a>.  These identifiers follow the same
rules of no shadowing and no assignment.</p><p>If the arguments have <a href="s_annotations.html" data-pltdoc="x">annotations</a> associated with
them, they are checked before the body of the function starts evaluating, in
order from left to right.  If an annotation fails, an exception is thrown.</p><pre class="pyret-highlight"><p>add1 = lam(x :: Number):
  x + 1
end
add1("not-a-number")
# Error: expected a Number and got "not-a-number"</p></pre><h5>2.1.6.2<tt>&nbsp;</tt><a name="(part._s~3aapp-expr)"></a>Application Expressions</h5><p>Function application expressions have the following grammar:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._app-expr)))"></a>&#8249;app-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <a href="#%28elem._%28bnf-prod._%28.Pyret._app-args%29%29%29" data-pltdoc="x">&#8249;app-args&#8250;</a>
<a name="(elem._(bnf-prod._(.Pyret._app-args)))"></a>&#8249;app-args&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._app-arg-elt%29%29%29" data-pltdoc="x">&#8249;app-arg-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Pyret._app-arg-elt)))"></a>&#8249;app-arg-elt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">,</span></p></blockquote><p>An application expression is an expression (usually expected to evaluate to a
function), followed by a comma-separated list of arguments enclosed in
parentheses.  It first evaluates the arguments in left-to-right order, then
evaluates the function position.  If the function position is a function value,
the number of provided arguments is checked against the number of arguments
that the function expects.  If they match, the arguments names are bound to the
provided values.  If they don&rsquo;t, an exception is thrown.</p><p>Note that there is <span style="font-style: italic">no space</span> allowed before the opening parenthesis of
the application.  If you make a mistake, Pyret will complain:</p><pre class="pyret-highlight"><p>f(1) # This is the function application expression f(1)
f (1) # This is the id-expr f, followed by the paren-expr (1)
# The second form yields a well-formedness error that there
# are two expressions on the same line</p></pre><h5>2.1.6.3<tt>&nbsp;</tt><a name="(part._s~3acurried-apply-expr)"></a>Curried Application Expressions</h5><p>Suppose a function is defined with multiple arguments:</p><pre class="pyret-highlight"><p>fun f(v, w, x, y, z): ... end</p></pre><p>Sometimes, it is particularly convenient to define a new function that
calls <span class="stt">f</span> with some arguments pre-specified:</p><pre class="pyret-highlight"><p>call-f-with-123 = lam(y, z): f(1, 2, 3, y, z) end</p></pre><p>Pyret provides syntactic sugar to make writing such helper functions
easier:</p><pre class="pyret-highlight"><p>call-f-with-123 = f(1, 2, 3, _, _) # same as the fun expression above</p></pre><p>Specifically, when Pyret code contains a function application some of
whose arguments are underscores, it constructs an anonymous function
with the same number of arguments as there were underscores in the
original expression, whose body is simply the original function
application, with the underscores replaced by the names of the
arguments to the anonymous function.</p><p>This syntactic sugar also works
with operators.  For example, the following are two ways to sum a list
of numbers:</p><pre class="pyret-highlight"><p>[list: 1, 2, 3, 4].foldl(lam(a, b): a + b end, 0)

[list: 1, 2, 3, 4].foldl(_ + _, 0)</p></pre><p>Likewise, the following are two ways to compare two lists for
equality:</p><pre class="pyret-highlight"><p>list.map_2(lam(x, y): x == y end, first-list, second-list)

list.map_2(_ == _, first-list, second-list)</p></pre><p>Note that there are some limitations to this syntactic sugar.  You
cannot use it with the <span class="stt">is</span> or <span class="stt">raises</span> expressions in
check blocks, since both test expressions and expected
outcomes are known when writing tests.  Also, note that the sugar is
applied only to one function application at a time.  As a result, the
following code:</p><pre class="pyret-highlight"><p>_ + _ + _</p></pre><p>desugars to</p><pre class="pyret-highlight"><p>lam(z):
  (lam(x, y): x + y end) + z
end</p></pre><p>which is probably not what was intended.  You can still write the
intended expression manually:</p><pre class="pyret-highlight"><p>lam(x, y, z): x + y + z end</p></pre><p>Pyret just does not provide syntactic sugar to help in this case
(or other more complicated ones).</p><h5>2.1.6.4<tt>&nbsp;</tt><a name="(part._s~3acannonball-expr)"></a>Chaining Application</h5><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._chain-app-expr)))"></a>&#8249;chain-app-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">^</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The expression <span class="pyret-highlight"><span class="stt">e1 ^ e2</span></span> is equivalent to <span class="pyret-highlight"><span class="stt">e2(e1)</span></span>.  It&rsquo;s just
another way of writing a function application to a single argument.</p><p>Sometimes, composing functions doesn&rsquo;t produce readable code.  For example, if
say we have a <span class="pyret-highlight"><span class="stt">Tree</span></span> datatype, and we have an <span class="pyret-highlight"><span class="stt">add</span></span> operation on
it, defined via a function.  To build up a tree with a series of adds, we&rsquo;d
write something like:</p><pre class="pyret-highlight"><p>t = add(add(add(add(empty-tree, 1), 2), 3), 4)</p></pre><p>Or maybe</p><pre class="pyret-highlight"><p>t1 = add(empty-tree, 1)
t2 = add(t1, 2)
t3 = add(t2, 3)
t  = add(t3, 4)</p></pre><p>If <span class="pyret-highlight"><span class="stt">add</span></span> were a method, we could write:</p><pre class="pyret-highlight"><p>t = empty-tree.add(1).add(2).add(3).add(4)</p></pre><p>which would be more readable, but since <span class="pyret-highlight"><span class="stt">add</span></span> is a function, this doesn&rsquo;t
work.</p><p>In this case, we can write instead:</p><pre class="pyret-highlight"><p>t = empty-tree ^ add(_, 1) ^ add(_, 2) ^ add(_, 3)</p></pre><p>This uses <a href="#%28part._s~3acurried-apply-expr%29" data-pltdoc="x">curried application</a> to create a
single argument function, and chaining application to apply it.  This can be
more readable across several lines of initialization as well, when compared to
composing &#8220;inside-out&#8221; or using several intermediate names:</p><pre class="pyret-highlight"><p>t = empty-tree
  ^ add(_, 1)
  ^ add(_, 2)
  ^ add(_, 3)
  # and so on</p></pre><h5>2.1.6.5<tt>&nbsp;</tt><a name="(part._s~3abinop-expr)"></a>Binary Operators</h5><p>There are a number of binary operators in Pyret.  A binary operator expression
is a series of expressions joined by binary operators. An expression itself
is also a binary operator expression.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._binop-expr)))"></a>&#8249;binop-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-meta">(</span><span class="bnf-lit bnf-unknown">BINOP</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span></p></blockquote><p>Each binary operator is syntactic sugar for a particular method or function
call.  The following table lists the operators, their intended use, and the
corresponding call:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">left + right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._plus(right)</span></p></td></tr><tr><td><p><span class="stt">left - right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._minus(right)</span></p></td></tr><tr><td><p><span class="stt">left * right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._times(right)</span></p></td></tr><tr><td><p><span class="stt">left / right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._divide(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &lt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._lessthan(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt;= right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterequal(right)</span></p></td></tr><tr><td><p><span class="stt">left &gt; right</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span class="stt">left._greaterthan(right)</span></p></td></tr></table></p><p>For the primitive strings and numbers, the operation happens internally.  For
all object values, the operator looks for the method appropriate method and
calls it.  The special names allow a form of operator overloading, and avoid
adding an extra concept beyond function and method calls to the core to
account for these binary operations.</p><h5>2.1.6.6<tt>&nbsp;</tt><a name="(part._s~3aobj-expr)"></a>Object Expressions</h5><p>Object expressions map field names to values:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._obj-expr)))"></a>&#8249;obj-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span><span class="bnf-meta"> | </span><span class="bnf-lit">{</span> <span class="bnf-lit">}</span>
<a name="(elem._(bnf-prod._(.Pyret._fields)))"></a>&#8249;fields&#8250;<span class="bnf-meta">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._list-field%29%29%29" data-pltdoc="x">&#8249;list-field&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._field%29%29%29" data-pltdoc="x">&#8249;field&#8250;</a> <span class="bnf-meta">[</span><span class="bnf-lit">,</span><span class="bnf-meta">]</span>
<a name="(elem._(bnf-prod._(.Pyret._list-field)))"></a>&#8249;list-field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._field%29%29%29" data-pltdoc="x">&#8249;field&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._field)))"></a>&#8249;field&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <span class="bnf-lit">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a>
          <span class="bnf-meta"> | </span><span class="bnf-lit">method</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._key%29%29%29" data-pltdoc="x">&#8249;key&#8250;</a> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._fun-header%29%29%29" data-pltdoc="x">&#8249;fun-header&#8250;</a> <span class="bnf-lit">:</span> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._doc-string%29%29%29" data-pltdoc="x">&#8249;doc-string&#8250;</a> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._where-clause%29%29%29" data-pltdoc="x">&#8249;where-clause&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._key)))"></a>&#8249;key&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p>A comma-separated sequence of fields enclosed in <span class="stt">{}</span> creates an object; we
refer to the expression as an <span style="font-style: italic">object literal</span>.  There are two types of
fields: <span style="font-style: italic">data</span> fields and <span style="font-style: italic">method</span> fields.  A data field in an object
literal simply creates a field with that name on the resulting object, with its
value equal to the right-hand side of the field. A method field</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">"method" key fun-header ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>is syntactic sugar for:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">key ":" "method" fun-header ":" doc-string block where-clause "end"</span></p></td></tr></table></blockquote><p>That is, it&rsquo;s just special syntax for a data field that contains a method
value.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The overriding of later fields is expected to be deprecated and
replaced with an error.</p></blockquote></blockquote></blockquote><p>The fields are evaluated in order.  If the same field appears more than once,
the later use overrides the earlier use, but both field expressions are still
evaluated.</p><h5>2.1.6.7<tt>&nbsp;</tt><a name="(part._s~3adot-expr)"></a>Dot Expressions</h5><p>A dot expression is any expression, followed by a dot and name:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._dot-expr)))"></a>&#8249;dot-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit bnf-unknown">NAME</span></p></blockquote><p>A dot expression evaluates the <span class="stt">expr</span> to a value <span class="stt">val</span>, and then does one
of five things:</p><ul><li><p>Raises an exception, if <span class="stt">NAME</span> is not a field of <span class="stt">expr</span></p></li><li><p>Evaluates to the value stored in <span class="stt">NAME</span>, if <span class="stt">NAME</span> is present and
not a method</p></li><li><p>If the <span class="stt">NAME</span> field is a method value, evaluates to a function that is
the <span style="font-style: italic">method binding</span> of the method value to <span class="stt">val</span>.  For a method</p><pre class="pyret-highlight"><p>m = method(self, x): body end</p></pre><p>The <span style="font-style: italic">method binding</span> of <span class="stt">m</span> to a value <span class="stt">v</span> is equivalent to:</p><pre class="pyret-highlight"><p>(lam(self): lam(x): body end end)(v)</p></pre><p>What this detail means is that you can look up a method and it
automatically closes over the value on the left-hand side of the dot.  This
bound method can be freely used as a function.</p><p>For example:</p><pre class="pyret-highlight"><p>o = { method m(self, x): self.y + x end, y: 22 }
check:
  the-m-method-closed-over-o = o.m
  the-m-method-closed-over-o(5) is 27
end</p></pre></li></ul><h5>2.1.6.8<tt>&nbsp;</tt><a name="(part._s~3aextend-expr)"></a>Extend Expressions</h5><p>The extend expression consists of an base expression and a list of fields to
extend it with:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._extend-expr)))"></a>&#8249;extend-expr&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">.</span> <span class="bnf-lit">{</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._fields%29%29%29" data-pltdoc="x">&#8249;fields&#8250;</a> <span class="bnf-lit">}</span></p></blockquote><p>The extend expression first evaluates <span class="stt">expr</span> to a value <span class="stt">val</span>, and then
creates a new object with all the fields of <span class="stt">val</span> and <span class="stt">fields</span>.  If a
field is present in both, the new field is used.</p><p>Examples:</p><pre class="pyret-highlight"><p>check:
  o = {x : "original-x", y: "original-y"}
  o2 = o.{x : "new-x", z : "new-z"}
  o2.x is "new-x"
  o2.y is "original-y"
  o2.z is "new-z"
end</p></pre><h5>2.1.6.9<tt>&nbsp;</tt><a name="(part._s~3aif-expr)"></a>If Expressions</h5><p>An if expression has a number of test conditions and an optional else case.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._if-expr)))"></a>&#8249;if-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">if</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._else-if%29%29%29" data-pltdoc="x">&#8249;else-if&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">else:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._else-if)))"></a>&#8249;else-if&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">else if</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>For example, this if expression has an "else:"</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre><p>This one does not:</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
end</p></pre><p>Both are valid.  The conditions are tried in order, and the block corresponding
to the first one to return <span class="pyret-highlight"><span class="stt">true</span></span> is evaluated.  If no condition matches,
the else branch is evaluated if present.  If no condition matches and no else
branch is present, an error is thrown.  If a condition evaluates to a value
other than <span class="pyret-highlight"><span class="stt">true</span></span> or <span class="pyret-highlight"><span class="stt">false</span></span>, a runtime error is thrown.</p><h5>2.1.6.10<tt>&nbsp;</tt><a name="(part._s~3aask-expr)"></a>Ask Expressions</h5><p>An <span class="pyret-highlight"><span class="stt">ask</span></span> expression is a different way of writing an <span class="pyret-highlight"><span class="stt">if</span></span>
expression that can be easier to read in some cases.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._ask-expr)))"></a>&#8249;ask-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">ask:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._ask-branch%29%29%29" data-pltdoc="x">&#8249;ask-branch&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">|</span> <span class="bnf-lit">otherwise:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._ask-branch)))"></a>&#8249;ask-branch&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a> <span class="bnf-lit">then:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>This ask expression:</p><pre class="pyret-highlight"><p>ask:
  | x == 0 then: 1
  | x &gt; 0 then: x
  | otherwise: x * -1
end</p></pre><p>is equivalent to</p><pre class="pyret-highlight"><p>if x == 0:
  1
else if x &gt; 0:
  x
else:
  x * -1
end</p></pre><p>Similar to <span class="pyret-highlight"><span class="stt">if</span></span>, if an <span class="pyret-highlight"><span class="stt">otherwise:</span></span> branch isn&rsquo;t specified and no
branch matches, a runtime error results.</p><h5>2.1.6.11<tt>&nbsp;</tt><a name="(part._s~3acases-expr)"></a>Cases Expressions</h5><p>A cases expression consists of a datatype (in parentheses), an expression to
inspect (before the colon), and a number of branches.  It is intended to be
used in a structure parallel to a data definition.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._cases-expr)))"></a>&#8249;cases-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">cases</span> <span class="bnf-lit">(</span> <font class="badlink">&#8249;check-ann&#8250;</font> <span class="bnf-lit">)</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">:</span> <span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._cases-branch%29%29%29" data-pltdoc="x">&#8249;cases-branch&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <span class="bnf-meta">[</span><span class="bnf-lit">|</span> <span class="bnf-lit">else</span> <span class="bnf-lit">=&gt;</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._cases-branch)))"></a>&#8249;cases-branch&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">|</span> <span class="bnf-lit bnf-unknown">NAME</span> <span class="bnf-meta">[</span><a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._args%29%29%29" data-pltdoc="x">&#8249;args&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">=&gt;</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a></p></blockquote><p>The <span class="pyret-highlight"><span class="stt">check-ann</span></span> must be a type, like <a href="lists.html#%28part._lists_.List%29" data-pltdoc="x"><span class="stt">List</span></a>.  Then
<span class="pyret-highlight"><span class="stt">expr</span></span> is evaluated and checked against the given annotation.  If
it has the right type, the cases are then checked.</p><p>Cases should use the names of the variants of the given data type as the
<span class="stt">NAME</span>s of each branch.  In the branch that matches, the fields of the
variant are bound, in order, to the provided <span class="stt">args</span>, and the right-hand side
of the <span class="stt">=&gt;</span> is evaluated in that extended environment.  An exception results
if the wrong number of arguments are given.</p><p>An optional <span class="stt">else</span> clause can be provided, which is evaluated if no cases
match.  If no <span class="stt">else</span> clause is provided, a default is used that raises an
exception.</p><p>For example, some cases expression on lists looks like:</p><pre class="pyret-highlight"><p>check:
  result = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | link(f, r) =&gt; "link"
  end
  result is "link"

  result2 = cases(List) [list: 1,2,3]:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result2 is else

  result3 = cases(List) empty:
    | empty =&gt; "empty"
    | else =&gt; "else"
  end
  result3 is "empty"
end</p></pre><h5>2.1.6.12<tt>&nbsp;</tt><a name="(part._s~3afor-expr)"></a>For Expressions</h5><p>For expressions consist of the <span class="stt">for</span> keyword, followed by a list of
<span class="stt">binding from expr</span> clauses in parentheses, followed by a block:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Pyret._for-expr)))"></a>&#8249;for-expr&#8250;<span class="bnf-meta">:</span> <span class="bnf-lit">for</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> <span class="bnf-lit">(</span> <span class="bnf-meta">[</span><span class="bnf-meta">(</span><a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind-elt%29%29%29" data-pltdoc="x">&#8249;for-bind-elt&#8250;</a><span class="bnf-meta">)</span><span class="bnf-meta">*</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind%29%29%29" data-pltdoc="x">&#8249;for-bind&#8250;</a><span class="bnf-meta">]</span> <span class="bnf-lit">)</span> <a href="Statements.html#%28elem._%28bnf-prod._%28.Pyret._return-ann%29%29%29" data-pltdoc="x">&#8249;return-ann&#8250;</a> <span class="bnf-lit">:</span> <a href="Blocks.html#%28elem._%28bnf-prod._%28.Pyret._block%29%29%29" data-pltdoc="x">&#8249;block&#8250;</a> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Pyret._for-bind-elt)))"></a>&#8249;for-bind-elt&#8250;<span class="bnf-meta">:</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._for-bind%29%29%29" data-pltdoc="x">&#8249;for-bind&#8250;</a> <span class="bnf-lit">,</span>
<a name="(elem._(bnf-prod._(.Pyret._for-bind)))"></a>&#8249;for-bind&#8250;<span class="bnf-meta">:</span> <font class="badlink">&#8249;binding&#8250;</font> <span class="bnf-lit">from</span> <a href="#%28elem._%28bnf-prod._%28.Pyret._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></p></blockquote><p>The for expression is just syntactic sugar for a
<a href="#%28part._s~3alam-expr%29" data-pltdoc="x"><span class="stt">lam-expr</span></a> and a <a href="#%28part._s~3aapp-expr%29" data-pltdoc="x"><span class="stt">app-expr</span></a>.  An expression</p><pre class="pyret-highlight"><p>for fun-expr(arg1 :: ann1 from expr1, ...) -&gt; ann-return:
  block
end</p></pre><p>is equivalent to:</p><pre class="pyret-highlight"><p>fun-expr(lam(arg1 :: ann1, ...) -&gt; ann-return: block end, expr1, ...)</p></pre><p>Using a <span class="stt">for-expr</span> can be a more natural way to call, for example, list
iteration functions because it puts the identifier of the function and the
value it draws from closer to one another.  Use of <span class="stt">for-expr</span> is a matter of
style; here is an example that compares <span class="stt">fold</span> with and without <span class="stt">for</span>:</p><pre class="pyret-highlight"><p>for fold(sum from 0, number from [list: 1,2,3,4]):
  sum + number
end

fold(lam(sum, number): sum + number end, 0, [list: 1,2,3,4])</p></pre><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="Statements.html" title="backward to &quot;2.1.5 Statements&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="s_forms.html" title="up to &quot;2.1 Language Constructs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="s_annotations.html" title="forward to &quot;2.1.7 Annotations&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>